"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var path = require('path');

var readPkgUp = require('read-pkg-up');

var sortKeys = require('sort-keys');

var fs = require('fs');

var pify = require('pify');

var JSON5 = require('json5');

var writeJsonFile = require('write-json-file');

var semver = require('semver');

var writeFile = require('write');

var crossSpawn = require('cross-spawn');

var hasYarn = require('has-yarn');

var _require = require('./packageData'),
    packages = _require.packages;

var diff = require('diff');

var upgradeDeps = require('./upgradeDeps');

var upgradeConfig = require('./upgradeConfig');

function isAcceptedNodeVersion() {
  return semver.satisfies(process.version, '>= 4');
}

function getLatestVersion() {
  return "^7.0.0";
}

function replaceMocha(str) {
  return str.replace(/--compilers\s+js:babel-core\/register/, '--compilers js:@babel/register').replace(/--compilers\s+js:babel-register/, '--compilers js:@babel/register').replace(/--require\s+babel-register/, '--require @babel/register').replace(/--require\s+babel-polyfill/, '--require @babel/polyfill');
}

function upgradeScripts(scripts) {
  var _arr = Object.keys(scripts);

  for (var _i = 0; _i < _arr.length; _i++) {
    var script = _arr[_i];
    scripts[script] = replaceMocha(scripts[script]);
  }

  return scripts;
}

function updatePackageJSON(_x) {
  return _updatePackageJSON.apply(this, arguments);
}

function _updatePackageJSON() {
  _updatePackageJSON = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee(pkg) {
    var options,
        _args = arguments;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};

            if (process.env.NODE_ENV !== 'test') {
              console.log("Updating closest package.json dependencies");
            }

            if (!pkg) {
              console.log("package.json not found");
              process.exit(1);
            }

            if (pkg.scripts) {
              pkg.scripts = upgradeScripts(pkg.scripts);

              if (Object.values(pkg.scripts).some(function (s) {
                return s.includes('babel-node');
              })) {
                if (pkg.devDependencies) {
                  pkg.devDependencies["@babel/node"] = getLatestVersion();
                }
              }
            }

            if (pkg.devDependencies) {
              pkg.devDependencies = sortKeys(upgradeDeps(pkg.devDependencies, getLatestVersion(), options)); // Adds preset-flow if needed, especially since it was split out of
              // preset-react

              if (options.hasFlow && !pkg.devDependencies['@babel/preset-flow']) {
                pkg.devDependencies['@babel/preset-flow'] = getLatestVersion();
              }
            }

            if (pkg.dependencies) {
              pkg.dependencies = sortKeys(upgradeDeps(pkg.dependencies, getLatestVersion(), options));
            } // ava


            if (pkg.ava) {
              if (pkg.ava.require && Array.isArray(pkg.ava.require)) {
                pkg.ava.require = pkg.ava.require.map(function (p) {
                  return packages[p] || p;
                });
              }

              if (pkg.ava.babel && pkg.ava.babel.testOptions) {
                pkg.ava.babel.testOptions = upgradeConfig(pkg.ava.babel.testOptions, options);
              }
            }

            return _context.abrupt("return", pkg);

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _updatePackageJSON.apply(this, arguments);
}

function prettyPrint(json) {
  return JSON.stringify(json, null, 2);
}

function showPatch(filename, before, after) {
  console.log(diff.createPatch(filename, before, after, "Before Upgrade", "After Upgrade"));
  console.log("");
}

function writePackageJSON(_x2) {
  return _writePackageJSON.apply(this, arguments);
}

function _writePackageJSON() {
  _writePackageJSON = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee2(options) {
    var _ref, pkg, path, oldPkg;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return readPkgUp({
              normalize: false
            });

          case 2:
            _ref = _context2.sent;
            pkg = _ref.pkg;
            path = _ref.path;
            oldPkg = prettyPrint(pkg);
            _context2.next = 8;
            return updatePackageJSON(pkg, options);

          case 8:
            pkg = _context2.sent;

            if (pkg.babel) {
              console.log("Updating package.json 'babel' config");
              pkg.babel = upgradeConfig(pkg.babel, options);
            }

            showPatch(path, oldPkg, prettyPrint(pkg));

            if (!options.write) {
              _context2.next = 14;
              break;
            }

            _context2.next = 14;
            return writeJsonFile(path, pkg, {
              detectIndent: true
            });

          case 14:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _writePackageJSON.apply(this, arguments);
}

function installDeps() {
  return _installDeps.apply(this, arguments);
}

function _installDeps() {
  _installDeps = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee3() {
    var command, args;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            command = hasYarn() ? 'yarn' : 'npm';
            args = ['install'];
            _context3.next = 4;
            return pify(crossSpawn)(command, args, {
              stdio: 'inherit'
            });

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _installDeps.apply(this, arguments);
}

function readBabelRC(_x3) {
  return _readBabelRC.apply(this, arguments);
}

function _readBabelRC() {
  _readBabelRC = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee4(configPath) {
    var rawFile;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.next = 3;
            return pify(fs.readFile)(configPath);

          case 3:
            rawFile = _context4.sent.toString('utf8');
            return _context4.abrupt("return", JSON5.parse(rawFile));

          case 7:
            _context4.prev = 7;
            _context4.t0 = _context4["catch"](0);
            throw new Error(`babel-upgrade: ${configPath} does not contain a valid .babelrc file. ${_context4.t0.stack}`);

          case 10:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[0, 7]]);
  }));
  return _readBabelRC.apply(this, arguments);
}

function writeBabelRC(_x4, _x5) {
  return _writeBabelRC.apply(this, arguments);
}

function _writeBabelRC() {
  _writeBabelRC = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee5(configPath, options) {
    var json, oldJson;
    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return readBabelRC(configPath);

          case 3:
            json = _context5.sent;
            _context5.next = 8;
            break;

          case 6:
            _context5.prev = 6;
            _context5.t0 = _context5["catch"](0);

          case 8:
            if (!json) {
              _context5.next = 17;
              break;
            }

            console.log(`Updating .babelrc config at ${configPath}`);
            oldJson = prettyPrint(json);
            json = upgradeConfig(json, options);
            showPatch(configPath, oldJson, prettyPrint(json));

            if (!options.write) {
              _context5.next = 16;
              break;
            }

            _context5.next = 16;
            return writeJsonFile(configPath, json, {
              detectIndent: true
            });

          case 16:
            ;

          case 17:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, null, [[0, 6]]);
  }));
  return _writeBabelRC.apply(this, arguments);
}

function writeMochaOpts(_x6, _x7) {
  return _writeMochaOpts.apply(this, arguments);
}

function _writeMochaOpts() {
  _writeMochaOpts = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee6(configPath, options) {
    var rawFile;
    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return pify(fs.readFile)(configPath);

          case 2:
            rawFile = _context6.sent.toString('utf8');
            showPatch(configPath, rawFile, replaceMocha(rawFile));

            if (!options.write) {
              _context6.next = 7;
              break;
            }

            _context6.next = 7;
            return writeFile(configPath, replaceMocha(rawFile));

          case 7:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _writeMochaOpts.apply(this, arguments);
}

module.exports = {
  isAcceptedNodeVersion,
  updatePackageJSON,
  writePackageJSON,
  readBabelRC,
  writeBabelRC,
  getLatestVersion,
  writeMochaOpts,
  installDeps
};